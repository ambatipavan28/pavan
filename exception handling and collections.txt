What is an Exception in java?
Exception handling in java helps in minimizing exceptions and helps in recovering from exceptions. It is one of the powerful mechanisms to handle runtime exceptions and makes it bug-free. Exception handling helps in maintaining the flow of the program.

Exception handling in java with an example:

Let’s say,
statement
statement
statement
exception ………… an exception occurred, then JVM will handle it and will exit the prog.
statement
statement
statement
For handling exceptions, there are 2 possible approaches
exception handling in java
1. JVM
If an exception is not handled explicitly, then JVM takes the responsibility of handling the exception.
Once the exception is handled, JVM will halt the program and no more execution of code will take place

Example:
import java.util.*;

class Main {
    public static void main (String[] args) {
        System.out.println(5/0);
        System.out.println("End of program!");
	}
}
Runtime Error:

 Exception in thread "main" java.lang.ArithmeticException: / by zero
 at Main.main(File.java:5) 
2. Developer
Developers can explicitly write the implementation for handling the exception. Once an exception is handled, the normal execution of code will continue.

Preferable: handle exceptions to ensure your code gets executed normally.
Java Try-Catch Block
Try-catch syntax:

try{
}
catch(Exception e){
}
Try-catch Example:
public class ExceptionDemo {
	public static void main (String[] args) {
		int a=10;
		for(int i=3;i>=0;i--)
		   try{
		     System.out.println(a/i);  
		   }catch(ArithmeticException e){
		       System.out.println(e);
		   }
	}
}
Output:
3
5
10
java.lang.ArithmeticException: / by zero 
try block contains the code that might throw an exception. Don’t write anything extra in try as statements after the exception will not get executed if the exception occurred. Try must be immediately followed by catch or finally block.
public class ExceptionDemo {
	public static void main (String[] args) {
		int a=10;
		for(int i=3;i>=0;i--)
		   try{
		     System.out.println(a/i);  
		   }
	}
}
Compile-time error:

prog.java:5: error: 'try' without 'catch', 'finally' or resource declarations
    try{
    ^
1 error 
The catch block is used to catch the exception thrown by statements in the try block. The catch must follow try else it will give a compile-time error.
public class ExceptionDemo {
	public static void main (String[] args) {
		int a=10;
		for(int i=3;i>=0;i--)
		   try{
		     System.out.println(a/i);  
		   }
		   System.out.println("between try and catch");
		   catch(ArithmeticException e){
		       System.out.println(e);
		   }
	}
}

Compile Time Error:
prog.java:5: error: 'try' without 'catch', 'finally' or resource declarations
    try{
    ^
prog.java:9: error: 'catch' without 'try'
    catch(ArithmeticException e){
    ^
2 errors 

Any group of individual objects which are represented as a single unit is known as the collection of the objects. In Java, a separate framework named the “Collection Framework” has been defined in JDK 1.2 which holds all the collection classes and interface in it.

The Collection interface (java.util.Collection) and Map interface (java.util.Map) are the two main “root” interfaces of Java collection classes.

Attention reader! Don’t stop learning now. Get hold of all the important Java Foundation and Collections concepts with the Fundamentals of Java and Java Collections Course at a student-friendly price and become industry ready. To complete your preparation from learning a language to DS Algo and many more,  please refer Complete Interview Preparation Course.

What is a Framework?

A framework is a set of classes and interfaces which provide a ready-made architecture. In order to implement a new feature or a class, there is no need to define a framework. However, an optimal object-oriented design always includes a framework with a collection of classes such that all the classes perform the same kind of task.

Need for a Separate Collection Framework

Before Collection Framework(or before JDK 1.2) was introduced, the standard methods for grouping Java objects (or collections) were Arrays or Vectors or Hashtables. All of these collections had no common interface. Therefore, though the main aim of all the collections are same, the implementation of all these collections were defined independently and had no correlation among them. And also, its very difficult for the users to remember all the different methods, syntax and constructors present in every collection class.

Let’s understand this with an example of adding an element in a hashtable and a vector.
import java.io.*;
import java.util.*;
class CollectionDemo {
    public static void main(String[] args)
    {
        int arr[] = new int[] { 1, 2, 3, 4 };
        Vector<Integer> v = new Vector();
        Hashtable<Integer, String> h
            = new Hashtable();
        v.addElement(1);
        v.addElement(2);
        h.put(1, "ppp");
        h.put(2, "qqq");
        System.out.println(arr[0]);
        System.out.println(v.elementAt(0));
        System.out.println(h.get(1));
    }
}

Output:
1
1
ppp
As we can observe, none of these collections(Array, Vector or Hashtable) implements a standard member access interface, it was very difficult for programmers to write algorithms that can work for all kinds of Collections. Another drawback is that most of the ‘Vector’ methods are final, meaning we cannot extend the ’Vector’ class to implement a similar kind of Collection. Therefore, Java developers decided to come up with a common interface to deal with the above-mentioned problems and introduced the Collection Framework in JDK 1.2 post which both, legacy Vectors and Hashtables were modified to conform to the Collection Framework.

Advantages of the Collection Framework: Since the lack of a collection framework gave rise to the above set of disadvantages, the following are the advantages of the collection framework.

Consistent API: The API has a basic set of interfaces like Collection, Set, List, or Map, all the classes (ArrayList, LinkedList, Vector, etc) that implement these interfaces have some common set of methods.
Reduces programming effort: A programmer doesn’t have to worry about the design of the Collection but rather he can focus on its best use in his program. Therefore, the basic concept of Object-oriented programming (i.e.) abstraction has been successfully implemented.
Increases program speed and quality: Increases performance by providing high-performance implementations of useful data structures and algorithms because in this case, the programmer need not think of the best implementation of a specific data structure. He can simply use the best implementation to drastically boost the performance of his algorithm/program.
Hierarchy of the Collection Framework
The utility package, (java.util) contains all the classes and interfaces that are required by the collection framework. The collection framework contains an interface named an iterable interface which provides the iterator to iterate through all the collections. This interface is extended by the main collection interface which acts as a root for the collection framework. All the collections extend this collection interface thereby extending the properties of the iterator and the methods of this interface. The following figure illustrates the hierarchy of the collection framework.

